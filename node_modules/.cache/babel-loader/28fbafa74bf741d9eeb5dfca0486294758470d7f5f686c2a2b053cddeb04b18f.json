{"ast":null,"code":"import { Client } from '@stomp/stompjs';\nimport SockJS from 'sockjs-client';\nclass WebSocketService {\n  constructor() {\n    this.client = null;\n    this.connected = false;\n    this.subscriptions = new Map();\n  }\n  connect() {\n    return new Promise((resolve, reject) => {\n      this.client = new Client({\n        webSocketFactory: () => new SockJS('http://localhost:8001/ws'),\n        connectHeaders: {},\n        debug: str => {\n          console.log('STOMP Debug:', str);\n        },\n        reconnectDelay: 5000,\n        heartbeatIncoming: 4000,\n        heartbeatOutgoing: 4000\n      });\n      this.client.onConnect = frame => {\n        console.log('Connected to WebSocket:', frame);\n        this.connected = true;\n        resolve(frame);\n      };\n      this.client.onStompError = frame => {\n        console.error('Broker reported error:', frame.headers['message']);\n        console.error('Additional details:', frame.body);\n        this.connected = false;\n        reject(frame);\n      };\n      this.client.onWebSocketError = error => {\n        console.error('WebSocket error:', error);\n        this.connected = false;\n        reject(error);\n      };\n      this.client.onDisconnect = () => {\n        console.log('Disconnected from WebSocket');\n        this.connected = false;\n      };\n      this.client.activate();\n    });\n  }\n  disconnect() {\n    if (this.client && this.connected) {\n      // Unsubscribe from all subscriptions\n      this.subscriptions.forEach(subscription => {\n        subscription.unsubscribe();\n      });\n      this.subscriptions.clear();\n      this.client.deactivate();\n      this.connected = false;\n    }\n  }\n  subscribeToRoom(roomId, onMessageReceived) {\n    if (!this.connected || !this.client) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n    const destination = `/topic/room/${roomId}`;\n\n    // Unsubscribe from previous subscription if exists\n    if (this.subscriptions.has(roomId)) {\n      this.subscriptions.get(roomId).unsubscribe();\n    }\n    const subscription = this.client.subscribe(destination, message => {\n      try {\n        const messageData = JSON.parse(message.body);\n        onMessageReceived(messageData);\n      } catch (error) {\n        console.error('Error parsing message:', error);\n      }\n    });\n    this.subscriptions.set(roomId, subscription);\n    return subscription;\n  }\n  sendMessage(roomId, messageRequest) {\n    if (!this.connected || !this.client) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n    try {\n      this.client.publish({\n        destination: `/app/sendMessage/${roomId}`,\n        body: JSON.stringify(messageRequest)\n      });\n      return true;\n    } catch (error) {\n      console.error('Error sending message:', error);\n      return false;\n    }\n  }\n  isConnected() {\n    return this.connected;\n  }\n}\nexport default new WebSocketService();","map":{"version":3,"names":["Client","SockJS","WebSocketService","constructor","client","connected","subscriptions","Map","connect","Promise","resolve","reject","webSocketFactory","connectHeaders","debug","str","console","log","reconnectDelay","heartbeatIncoming","heartbeatOutgoing","onConnect","frame","onStompError","error","headers","body","onWebSocketError","onDisconnect","activate","disconnect","forEach","subscription","unsubscribe","clear","deactivate","subscribeToRoom","roomId","onMessageReceived","destination","has","get","subscribe","message","messageData","JSON","parse","set","sendMessage","messageRequest","publish","stringify","isConnected"],"sources":["/Users/lakshya.munna/Desktop/chat-room-app/src/services/websocket.js"],"sourcesContent":["import { Client } from '@stomp/stompjs';\nimport SockJS from 'sockjs-client';\n\nclass WebSocketService {\n  constructor() {\n    this.client = null;\n    this.connected = false;\n    this.subscriptions = new Map();\n  }\n\n  connect() {\n    return new Promise((resolve, reject) => {\n      this.client = new Client({\n        webSocketFactory: () => new SockJS('http://localhost:8001/ws'),\n        connectHeaders: {},\n        debug: (str) => {\n          console.log('STOMP Debug:', str);\n        },\n        reconnectDelay: 5000,\n        heartbeatIncoming: 4000,\n        heartbeatOutgoing: 4000,\n      });\n\n      this.client.onConnect = (frame) => {\n        console.log('Connected to WebSocket:', frame);\n        this.connected = true;\n        resolve(frame);\n      };\n\n      this.client.onStompError = (frame) => {\n        console.error('Broker reported error:', frame.headers['message']);\n        console.error('Additional details:', frame.body);\n        this.connected = false;\n        reject(frame);\n      };\n\n      this.client.onWebSocketError = (error) => {\n        console.error('WebSocket error:', error);\n        this.connected = false;\n        reject(error);\n      };\n\n      this.client.onDisconnect = () => {\n        console.log('Disconnected from WebSocket');\n        this.connected = false;\n      };\n\n      this.client.activate();\n    });\n  }\n\n  disconnect() {\n    if (this.client && this.connected) {\n      // Unsubscribe from all subscriptions\n      this.subscriptions.forEach((subscription) => {\n        subscription.unsubscribe();\n      });\n      this.subscriptions.clear();\n      \n      this.client.deactivate();\n      this.connected = false;\n    }\n  }\n\n  subscribeToRoom(roomId, onMessageReceived) {\n    if (!this.connected || !this.client) {\n      console.error('WebSocket not connected');\n      return null;\n    }\n\n    const destination = `/topic/room/${roomId}`;\n    \n    // Unsubscribe from previous subscription if exists\n    if (this.subscriptions.has(roomId)) {\n      this.subscriptions.get(roomId).unsubscribe();\n    }\n\n    const subscription = this.client.subscribe(destination, (message) => {\n      try {\n        const messageData = JSON.parse(message.body);\n        onMessageReceived(messageData);\n      } catch (error) {\n        console.error('Error parsing message:', error);\n      }\n    });\n\n    this.subscriptions.set(roomId, subscription);\n    return subscription;\n  }\n\n  sendMessage(roomId, messageRequest) {\n    if (!this.connected || !this.client) {\n      console.error('WebSocket not connected');\n      return false;\n    }\n\n    try {\n      this.client.publish({\n        destination: `/app/sendMessage/${roomId}`,\n        body: JSON.stringify(messageRequest)\n      });\n      return true;\n    } catch (error) {\n      console.error('Error sending message:', error);\n      return false;\n    }\n  }\n\n  isConnected() {\n    return this.connected;\n  }\n}\n\nexport default new WebSocketService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}